---
layout: default
title:  Project Euler - Problem 2
date:   2018-05-10 16:00:00 -0400
categories: ProjectEuler
permalink: "/pe/2"
---

# Project Euler Problem 2

>
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:<br/><br/>
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...<br/><br/>
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.<br/><br/>

Note: Project Euler chooses to start the sequence with 1, 2. Traditionally it is started with 1, 1, 2. This isn't really an issue for this problem as this extra 1 is not even. I will use the 1, 1, 2 sequence as it makes some of the math a bit cleaner. It does not change the results though.

## Naive Approach

The naive approach is to iterate over the sequence, adding the even numbers to a running total, until we reach our upper bound. That would look something like this:

{% highlight python %}
def fib(lim):
    a, b = 1, 1
    while b <= lim:
        b, a = a+b, b
        yield a

def fibsum1(n):
    s = 0
    for i in fib(n):
        print i
        if i % 2 == 0:
            s += i

    return s
{% endhighlight %}


This solution certainly works, but it is order O(lg n) as there are O(lg n) Fibonacci numbers less than n (this will be shown later). O(lg n) is great, but an O(lg lg n) solution is possible with some math.

## Some Math

Lets put parentheses around the odd terms in the given sequence:

`(1 + 1) + 2 + (3 + 5) + 8 + (13 + 21) + 34 + (55 + 89) + 144...`

Notice that every third term in the sequence is even. Given the definition then of the Fibonacci sequence, each even number is going to be equal to the sum of the two previous odd numbers. From this it follows that the sum of the even numbers in the Fibonacci sequence is going to be equal to the sum of the odd numbers in the Fibonacci sequence. In other words, because all numbers in the sequence are either odd or even, the sum of the even numbers will be half the sum of all of the numbers. This is a truly beautiful result and gets us closer to an explicit solution to the problem.

Note: if the last number in a partial sum is odd, we instead want to backtrack through the sequence until we find the first even number. For instance, if our upper bound is 33, we are only interested in the evens 2 and 8, but 13 and 21 would also be in the sequence. When we take the partial sum to 21, we have extra odd numbers that don't have an even partner, in this case 34. Again, this can be remedied simply by backtracking until we find an even number.

What we need now is to find an explicit formula for the sum of the first n Fibonacci numbers. Consider the following table:

| Sequence    | 1 | 1 | 2 | 3 | 5  | 8  | 13 | 21 | 34 | 55  | 89  | 144 | x |
|-------------|---|---|---|---|----|----|----|----|----|-----|-----|-----|---|
| Partial Sum | 1 | 2 | 4 | 7 | 12 | 20 | 33 | 54 | 88 | 143 | x-1 |     |   |

Notice that it appears that the sum of the first n Fibonacci numbers is equal to the (n+2)th Fibonacci number, minus 1. This result can be verified via proof by induction. This fact reduces the problem to finding an explicit formula for the nth Fibonacci number.

Such a formula exists. This formula isn't trivial though, so I won't reproduce the proof here. The formula is:

`fib(n) = ((Phi**n - (-phi)**n)/(5**0.5))`

where Phi is the golden ratio `(1+5**0.5)*0.5` and phi is Phi-1. (Notice the difference in Phi and phi). Because phi is less than 1, phi^n is also less than 1. Therefore, fib(n) is approximately `(Phi**n)/(5**0.5).` We're interested only in Fibonacci numbers less than fib(n) = 4,000,000. We can solve this approximation for n in order to find the index of the nearest Fibonacci number to x which is smaller than x. With some algebra we find that:

`n = floor(log(x*5**0.5)/log(Phi))`

This will give us the index of the number in the sequence closest to and less than or equal to our upper bound. This number may or may not be even. If this number is not even, we want to reduce the index n until fib(n) is even. If we don't do this, the sum we calculate will have 1 or 2 odd numbers in it that do not correspond an even number, as discussed earlier.

## A Faster Approach

Given all of this, we have arrived at a more efficient solution. Implementing these ideas we get something that looks like this:

{% highlight python %}
Phi = (1+5**0.5)*0.5
phi = Phi-1

def approx_n(x):
    return log(x*5**0.5)/log(Phi)

def nthfib(n):
    return int((Phi**n - (-phi)**n)/(5**0.5))

def fibsum2(lim):
    n = int(approx_n(lim))
    while nthfib(n) % 2 == 1:
        n -= 1
    return int(nthfib(n+2)-1)/2
{% endhighlight %}

The `approx_n(x)` function relies on the `log()` function, which is O(lg lg x) at the very worst. The value from `approx_n(x)` is O(lg x). This value is then plugged into `nthfib(n)` which relies on exponentiation. Exponentiation can be done in O(lg n). Because n is O(lg x), `nthfib(n)` itself is O(lg lg x). `nthfib(n)` is run no more than 4 times, so the runtime complexity for the entire program is O(lg lg x).
