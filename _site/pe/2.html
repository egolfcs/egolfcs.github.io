<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Project Euler - Problem 2 | Egolfcs</title>
<meta name="generator" content="Jekyll v3.8.1" />
<meta property="og:title" content="Project Euler - Problem 2" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Project Euler Problem 2" />
<meta property="og:description" content="Project Euler Problem 2" />
<link rel="canonical" href="http://localhost:4000/pe/2" />
<meta property="og:url" content="http://localhost:4000/pe/2" />
<meta property="og:site_name" content="Egolfcs" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-10T16:00:00-04:00" />
<script type="application/ld+json">
{"description":"Project Euler Problem 2","@type":"BlogPosting","url":"http://localhost:4000/pe/2","headline":"Project Euler - Problem 2","dateModified":"2018-05-10T16:00:00-04:00","datePublished":"2018-05-10T16:00:00-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/pe/2"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
    <script src="/assets/js/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="/assets/css/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <style type="text/css">
        .logo:hover { COLOR: WHITE; TEXT-DECORATION: none; font-weight: none }
    </style>
  </head>
  <body>
      

    <div class="wrapper">

      <section>
        <div id="title">
          <a href="/index.html"><h1 class="logo">Egolfcs</h1></a>
          <p></p>
          <hr>
        </div>

        <h1 id="project-euler-problem-2">Project Euler Problem 2</h1>

<blockquote>

  <p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:<br /><br />
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …<br /><br />
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.<br /><br /></p>
</blockquote>

<p>Note: Project Euler chooses to start the sequence with 1, 2. Traditionally it is started with 1, 1, 2. This isn’t really an issue for this problem as this extra 1 is not even. I will use the 1, 1, 2 sequence as it makes some of the math a bit cleaner. It does not change the results though.</p>

<h2 id="naive-approach">Naive Approach</h2>

<p>The naive approach is to iterate over the sequence, adding the even numbers to a running total, until we reach our upper bound. That would look something like this:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">lim</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="n">lim</span><span class="p">:</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span>
        <span class="k">yield</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">fibsum1</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">print</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">i</span>

    <span class="k">return</span> <span class="n">s</span></code></pre></figure>

<p>This solution certainly works, but it is order O(lg n) as there are O(lg n) Fibonacci numbers less than n (this will be shown later). O(lg n) is great, but an O(lg lg n) solution is possible with some math.</p>

<h2 id="some-math">Some Math</h2>

<p>Lets put parentheses around the odd terms in the given sequence:</p>

<p><code class="highlighter-rouge">(1 + 1) + 2 + (3 + 5) + 8 + (13 + 21) + 34 + (55 + 89) + 144...</code></p>

<p>Notice that every third term in the sequence is even. Given the definition then of the Fibonacci sequence, each even number is going to be equal to the sum of the two previous odd numbers. From this it follows that the sum of the even numbers in the Fibonacci sequence is going to be equal to the sum of the odd numbers in the Fibonacci sequence. In other words, because all numbers in the sequence are either odd or even, the sum of the even numbers will be half the sum of all of the numbers. This is a truly beautiful result and gets us closer to an explicit solution to the problem.</p>

<p>Note: if the last number in a partial sum is odd, we instead want to backtrack through the sequence until we find the first even number. For instance, if our upper bound is 33, we are only interested in the evens 2 and 8, but 13 and 21 would also be in the sequence. When we take the partial sum to 21, we have extra odd numbers that don’t have an even partner, in this case 34. Again, this can be remedied simply by backtracking until we find an even number.</p>

<p>What we need now is to find an explicit formula for the sum of the first n Fibonacci numbers. Consider the following table:</p>

<table>
  <thead>
    <tr>
      <th>Sequence</th>
      <th>1</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>5</th>
      <th>8</th>
      <th>13</th>
      <th>21</th>
      <th>34</th>
      <th>55</th>
      <th>89</th>
      <th>144</th>
      <th>x</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Partial Sum</td>
      <td>1</td>
      <td>2</td>
      <td>4</td>
      <td>7</td>
      <td>12</td>
      <td>20</td>
      <td>33</td>
      <td>54</td>
      <td>88</td>
      <td>143</td>
      <td>x-1</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>Notice that it appears that the sum of the first n Fibonacci numbers is equal to the (n+2)th Fibonacci number, minus 1. This result can be verified via proof by induction. This fact reduces the problem to finding an explicit formula for the nth Fibonacci number.</p>

<p>Such a formula exists. This formula isn’t trivial though, so I won’t reproduce the proof here. The formula is:</p>

<p><code class="highlighter-rouge">fib(n) = ((Phi**n - (-phi)**n)/(5**0.5))</code></p>

<p>where Phi is the golden ratio <code class="highlighter-rouge">(1+5**0.5)*0.5</code> and phi is Phi-1. (Notice the difference in Phi and phi). Because phi is less than 1, phi^n is also less than 1. Therefore, fib(n) is approximately <code class="highlighter-rouge">(Phi**n)/(5**0.5).</code> We’re interested only in Fibonacci numbers less than fib(n) = 4,000,000. We can solve this approximation for n in order to find the index of the nearest Fibonacci number to x which is smaller than x. With some algebra we find that:</p>

<p><code class="highlighter-rouge">n = floor(log(x*5**0.5)/log(Phi))</code></p>

<p>This will give us the index of the number in the sequence closest to and less than or equal to our upper bound. This number may or may not be even. If this number is not even, we want to reduce the index n until fib(n) is even. If we don’t do this, the sum we calculate will have 1 or 2 odd numbers in it that do not correspond an even number, as discussed earlier.</p>

<h2 id="a-faster-approach">A Faster Approach</h2>

<p>Given all of this, we have arrived at a more efficient solution. Implementing these ideas we get something that looks like this:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">Phi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">5</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span>
<span class="n">phi</span> <span class="o">=</span> <span class="n">Phi</span><span class="o">-</span><span class="mi">1</span>

<span class="k">def</span> <span class="nf">approx_n</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="mi">5</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="n">Phi</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">nthfib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">((</span><span class="n">Phi</span><span class="o">**</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="o">-</span><span class="n">phi</span><span class="p">)</span><span class="o">**</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">5</span><span class="o">**</span><span class="mf">0.5</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">fibsum2</span><span class="p">(</span><span class="n">lim</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">approx_n</span><span class="p">(</span><span class="n">lim</span><span class="p">))</span>
    <span class="k">while</span> <span class="n">nthfib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">nthfib</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span></code></pre></figure>

<p>The <code class="highlighter-rouge">approx_n(x)</code> function relies on the <code class="highlighter-rouge">log()</code> function, which is O(lg lg x) at the very worst. The value from <code class="highlighter-rouge">approx_n(x)</code> is O(lg x). This value is then plugged into <code class="highlighter-rouge">nthfib(n)</code> which relies on exponentiation. Exponentiation can be done in O(lg n). Because n is O(lg x), <code class="highlighter-rouge">nthfib(n)</code> itself is O(lg lg x). <code class="highlighter-rouge">nthfib(n)</code> is run no more than 4 times, so the runtime complexity for the entire program is O(lg lg x).</p>


      </section>

    </div>

    
  </body>
  <div class="wrapper">

    <section>
      <div id="title">
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
      </div>
  </div>
</html>
